自定义锁
实现Lock 接口 
定义内部类（AQS） AQS使用模板方法
实现所需的方法

AQS维护双向队列
线程未获取锁进入队列
调取获取锁方法（自旋获取），获取到锁出队列
将当前节点通过setHead()方法设置为队列的头结点，
然后将之前的头结点的next域设置为null并且pre域也为null，
即与队列断开，无任何引用方便GC时能够将内存进行回收。


总结：
在获取同步状态时，AQS维护一个同步队列，
获取同步状态失败的线程会加入到队列中进行自旋；
移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。
在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。


ReentrantLock
可重入锁 统一线程多次获取锁资源 计数器维护获取次数 释放锁的时候需要计数器清零即多次释放
公平锁 判断当前节点是否为AQS中头结点保证绝对顺序
非公平锁 所有节点都可获取 默认非公平锁

ReentrantReadWriteLock
写锁获取：
    当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；
    否则，获取成功并支持重入，增加写状态
读锁获取：（读锁是共享锁可以多个线程同时获取）
    当写锁被其他线程获取后，读锁获取失败
锁降级
    写锁可以降级为读锁
condition
维护一个等待队列 （单向列表）
当线程获取锁后 调用condition.await让当前线程尾插入等待队列释放锁资源
其它线程获取所资源调用signal/signalAll 此时将会把等待队列的数据加入到
AQS双向队列内 signal 将等待队列的头部节点加入 signalAll 是所有的节点



LockSupport
阻塞进程park()
唤醒进程unpark()

